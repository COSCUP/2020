// Copyright (c) 2020 DevilTea
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

/* eslint-disable @typescript-eslint/no-var-requires */
import fs from 'fs'
import path from 'path'
import { camelCase } from 'lodash'

interface RawLanguagePackUnit {
  [key: string]: RawLanguagePackUnit;
}

interface LanguageServiceConfig {
  default: string;
}

class LanguagePackBuilder {
  private _rawLanguagePack: RawLanguagePackUnit = {}
  private _stack: { key: string; unit: RawLanguagePackUnit }[] = []

  public add (key: string, value: RawLanguagePackUnit) {
    let node: RawLanguagePackUnit
    if (this._stack.length > 0) {
      node = this._stack.slice(-1)[0].unit
    } else {
      node = this._rawLanguagePack
    }
    if (typeof node[key] === 'object') {
      node[key] = Object.assign(node[key], value)
    } else {
      node[key] = value
    }
  }

  public startBuildChild (key: string) {
    this._stack.push({
      key,
      unit: {}
    })
  }

  public endBuildChild () {
    const unitData = this._stack.pop()
    if (!unitData) throw new Error('The stack is empty')
    this.add(unitData.key, unitData.unit)
  }

  public getResult () {
    while (this._stack.length > 0) {
      this.endBuildChild()
    }
    return this._rawLanguagePack
  }
}

function isDirectorySync (dirPath: string) {
  return fs.existsSync(dirPath) && fs.lstatSync(dirPath).isDirectory()
}

function visitRecursively (builder: LanguagePackBuilder, dirPath: string) {
  fs.readdirSync(dirPath)
    .sort((a, b) => (isDirectorySync(path.join(dirPath, a)) ? 1 : 0) - (isDirectorySync(path.join(dirPath, b)) ? 1 : 0))
    .forEach((filename) => {
      const filePath = path.join(dirPath, filename)
      if (isDirectorySync(filePath)) {
        builder.startBuildChild(filename)
        visitRecursively(builder, filePath)
        builder.endBuildChild()
      } else if (filename.endsWith('.json')) {
        const key = filename.replace(/\.json$/, '')
        const unit: RawLanguagePackUnit = require(filePath)
        builder.add(key, unit)
      }
    })
}

const languagesRoot = path.join(__dirname, '../languages/')
const targetDir = path.join(__dirname, '../src/services/language/languages/')
const config: LanguageServiceConfig = require(path.join(languagesRoot, 'config.json'))
const defaultLanguage = config.default

const languages = fs.readdirSync(languagesRoot)
  .filter((filename) => isDirectorySync(path.join(languagesRoot, filename)))

if (!languages.includes(defaultLanguage)) throw new Error('Invalid default language')

languages.forEach((language) => {
  const builder = new LanguagePackBuilder()
  visitRecursively(builder, path.join(languagesRoot, language))
  const resultJSON = JSON.stringify(builder.getResult(), null, 2)
  fs.writeFileSync(path.join(targetDir, `${language}.json`), resultJSON)
})

const result = `
// !WARNING! This file is auto-generated by /scripts/generateLanguagesImport.ts, so all your modifications would be replaced.

${languages.map((language) => `import ${camelCase(language)} from './${language}.json'`).join('\n')}

export type LanguageType = ${languages.map((language) => `'${language}'`).join(' | ')}

export const defaultLanguageType: LanguageType = '${defaultLanguage}'

export const availableLanguageTypes: LanguageType[] = [${languages.map((language) => `'${language}'`).join(', ')}]

export type LanguagePack = typeof ${camelCase(defaultLanguage)}

export type LanguagePackSet = {
  [languageType in LanguageType]: LanguagePack
}

export const languagePackSet: LanguagePackSet = {
  ${languages.map((language) => `${language === camelCase(language) ? language : `'${language}'`}: ${camelCase(language)}`).join(',\n  ')}
}
`.trimStart()

fs.writeFileSync(path.join(targetDir, 'index.ts'), result)
fs.writeFileSync(path.join(languagesRoot, 'languages.json'), JSON.stringify(languages, null, 2))
